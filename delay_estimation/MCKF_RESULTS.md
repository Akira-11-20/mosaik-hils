# MCKF実装結果まとめ

## 実装バージョン比較

### 簡略版（Ā_{j,n} ≈ 1）
- s1: 0.9388 ± 0.2762 (+29.1%)
- s2: 0.9131 ± 0.2363 (+27.3%)
- s3: 0.2145 ± 0.0537 (+23.9%)
- s4: 0.2080 ± 0.0536 (+35.7%)

### 厳密版（Bernoulli確率使用）- 確率修正後
- s1: 0.9688 ± 0.2850 (+33.2%)
- s2: 0.9485 ± 0.2505 (+32.3%)
- s3: 0.2212 ± 0.0561 (+27.8%)
- s4: 0.2144 ± 0.0556 (+39.8%)

### 論文の結果（Table 3）
- s1: 0.7274
- s2: 0.7172
- s3: 0.1731
- s4: 0.1533

## 分析

### 厳密版で精度が悪化した理由

厳密版では`delay_probs = [0.7, 0.24, 0.12, 0.06]`を使用していますが、
`_compute_A_bar()`の実装が不完全です：

```python
def _compute_A_bar(self, r: int, delay: int) -> float:
    if r == 0:
        return self.delay_probs[0]  # Λ̄_0 = 0.7
    if 0 <= r <= K:
        return self.delay_probs[r]  # 直接確率を返す（簡略版）
    return self.delay_probs[-1]
```

### 問題点

論文のĀ_{r,n}の正確な定義（ページ4）:

```
A_{r,n} = (1-Λ_{0,n}) * (1-Λ_{0,n-r}) * ∏_{i=1}^{r} Λ_{i,n-r+1}
          * (1-Λ_{r+1,n-r+1}) * ∏_{t=1}^{r-1} [複雑な積]
```

現在の実装は`Ā_{r,n} = delay_probs[r]`としているだけで、
上記の複雑な積の期待値を計算していません。

### 正しい実装

1. **A_{0,n} = Λ_{0,n}** → `Ā_{0,n} = Λ̄_0 = 0.7` ✓

2. **A_{1,n} = (1-Λ_{0,n})(1-Λ_{0,n-1})Λ_{1,n}(1-Λ_{2,n})**
   - 時不変系: `Ā_{1,n} ≈ (1-Λ̄_0)^2 * Λ̄_1 * (1-Λ̄_2)`
   - = `0.3^2 * 0.24 * 0.88 = 0.019`
   - 現在: `0.24` ← **12倍大きい！**

3. **A_{2,n}** も同様に複雑な積

### R̄への影響

式(12)の第1項:
```
R̄ = Σ_{t=0}^{k-1} Ā_{t,n} * R
```

現在の実装:
```
Ā_0 + Ā_1 + Ā_2 = 0.7 + 0.24 + 0.12 = 1.06
```

正しい実装（推定）:
```
Ā_0 + Ā_1 + Ā_2 ≈ 0.7 + 0.019 + ... ≈ 0.72
```

→ R̄が約1.5倍大きくなり、観測ノイズが過大評価され、
フィルタの性能が劣化している。

## 次のステップ

1. `_compute_A_bar()`の完全実装
2. 論文のBernoulli変数の積の期待値の正確な計算
3. 時変系の完全対応

## 結論

- ✅ MCKFの基本アルゴリズムは正常動作
- ✅ 遅延処理は機能
- ✅ 収束性能は良好
- ❌ Bernoulli確率の計算が不完全
- ❌ 論文レベルの精度には到達していない

定性的には正しいが、定量的な精度向上には
Ā_{r,n}の厳密計算が必要。
