"""Command Inverse Compensation Demo for HILS.

This script demonstrates command inverse compensation (also known as command feedforward
or command shaping) to counteract command path delays. Unlike sensor delay compensation,
this approach pre-shapes the command signal sent to the actuator.

Run this script to compare system response with and without command inverse compensation.
Metrics include RMSE, tracking error, and step response characteristics.

指令逆補償（Command Inverse Compensation）のデモンストレーション用スクリプト。
制御器からアクチュエータへの指令経路の遅延を補償します。
センサー遅延補償とは異なり、アクチュエータに送る指令信号を事前整形します。
"""

from __future__ import annotations

from collections import deque
from dataclasses import dataclass
from pathlib import Path
from typing import Tuple

import matplotlib.pyplot as plt
import numpy as np


@dataclass
class CommandCompConfig:
    """Command inverse compensation demo configuration"""

    # Time parameters
    Ts: float = 0.01  # Sampling period [s]
    Tend: float = 20.0  # Simulation end time [s]

    # Communication delay (command path: Controller → Actuator)
    tau_cmd: float = 0.15  # Command delay [s]

    # Plant dynamics (2nd order system: mass-spring-damper)
    # x[k] = a1*x[k-1] + a2*x[k-2] + b0*u[k] + b1*u[k-1]
    a1: float = 1.8  # System coefficient 1
    a2: float = -0.85  # System coefficient 2
    b0: float = 0.005  # Input gain (current step)
    b1: float = 0.005  # Input gain (previous step)

    # Input signal parameters (reference trajectory)
    sine_amp: float = 0.2  # Sine wave amplitude
    sine_freq_hz: float = 0.3  # Sine wave frequency [Hz]
    step_time: float = 2.0  # Step command time [s]
    step_amp: float = 0.5  # Step command amplitude

    @property
    def sample_count(self) -> int:
        """Total number of samples"""
        return int(self.Tend / self.Ts)

    @property
    def delay_samples(self) -> int:
        """Command delay in samples"""
        return int(round(self.tau_cmd / self.Ts))

    @property
    def inverse_gain(self) -> float:
        """Inverse compensation gain

        For command inverse compensation, we use a moderate gain.
        Too large gain (like delay_samples) can cause overshoot and instability.
        A good starting point is around 1.5-3.0 for typical systems.
        """
        # Use a fraction of delay_samples for stability
        # You can tune this value (try 1.5, 2.0, 3.0, etc.)
        return 15


def build_reference_signal(cfg: CommandCompConfig) -> Tuple[np.ndarray, np.ndarray]:
    """Generate reference command signal (sine + step)

    This represents the desired control command generated by the controller.

    Args:
        cfg: Configuration

    Returns:
        t: Time array [s]
        u_ref: Reference command signal
    """
    t = np.arange(cfg.sample_count) * cfg.Ts
    sine = cfg.sine_amp * np.sin(2.0 * np.pi * cfg.sine_freq_hz * t)
    step = cfg.step_amp * (t >= cfg.step_time).astype(float)
    u_ref = sine + step
    return t, u_ref


def apply_command_delay(cmd: np.ndarray, delay_samples: int) -> np.ndarray:
    """Apply delay to command signal (Controller → Actuator delay)

    Simulates communication delay in the command path using FIFO buffer.

    Args:
        cmd: Original command signal
        delay_samples: Delay in samples

    Returns:
        cmd_delayed: Delayed command signal
    """
    if delay_samples < 0:
        raise ValueError("delay_samples must be non-negative")

    buffer = deque([0.0] * delay_samples, maxlen=delay_samples or 1)
    cmd_delayed = np.zeros_like(cmd)

    for k, value in enumerate(cmd):
        buffer.append(value)
        cmd_delayed[k] = buffer[0]

    return cmd_delayed


def apply_command_inverse_compensation(u_ref: np.ndarray, gain: float) -> np.ndarray:
    """Apply command inverse compensation

    Inverse compensation formula:
        u_comp[k] = a * u_ref[k] - (a - 1) * u_ref[k-1]

    where a = delay_samples (command delay in samples)

    Theoretical background:
    - Command delay is represented as z^(-d) in z-transform
    - To cancel this delay, we apply approximate inverse z^d
    - This is realized using first-order difference compensation
    - Larger 'a' provides stronger compensation but may amplify noise

    This compensation is applied BEFORE the delay, so:
        Controller → [Inverse Comp] → [Delay] → Actuator

    The goal is that after going through delay, the signal matches the original.

    Args:
        u_ref: Reference command from controller
        gain: Inverse compensation gain (typically = delay_samples)

    Returns:
        u_comp: Pre-compensated command (to be sent through delayed channel)
    """
    if len(u_ref) == 0:
        return np.array([])

    u_comp = np.zeros_like(u_ref)
    prev = u_ref[0]
    u_comp[0] = prev  # Initial value

    for k in range(1, len(u_ref)):
        curr = u_ref[k]
        # Inverse compensation: emphasize current, subtract previous
        # This creates a "lead" effect that counteracts the upcoming delay
        u_comp[k] = gain * curr - (gain - 1.0) * prev
        prev = curr

    return u_comp


def propagate_second_order(u: np.ndarray, cfg: CommandCompConfig) -> np.ndarray:
    """Propagate 2nd-order plant dynamics

    Difference equation: x[k] = a1*x[k-1] + a2*x[k-2] + b0*u[k] + b1*u[k-1]

    This represents a discrete-time 2nd-order system (e.g., mass-spring-damper).

    Args:
        u: Input signal (actuator command)
        cfg: Configuration (a1, a2, b0, b1 parameters)

    Returns:
        x: Plant output (system state)
    """
    x = np.zeros_like(u)

    if len(u) > 0:
        x[0] = cfg.b0 * u[0]
    if len(u) > 1:
        x[1] = cfg.a1 * x[0] + cfg.b0 * u[1] + cfg.b1 * u[0]

    for k in range(2, len(u)):
        x[k] = cfg.a1 * x[k - 1] + cfg.a2 * x[k - 2] + cfg.b0 * u[k] + cfg.b1 * u[k - 1]

    return x


def rmse(a: np.ndarray, b: np.ndarray) -> float:
    """Calculate Root Mean Square Error"""
    return float(np.sqrt(np.mean((a - b) ** 2)))


def estimate_lag(ref: np.ndarray, sig: np.ndarray, Ts: float) -> Tuple[int, float]:
    """Estimate lag between two signals using cross-correlation

    Args:
        ref: Reference signal
        sig: Signal to compare (may be delayed)
        Ts: Sampling period [s]

    Returns:
        lag_samples: Estimated lag in samples
        lag_ms: Estimated lag in milliseconds
    """
    # Use differentiation to remove DC offset
    ref_d = np.diff(ref, prepend=ref[0])
    sig_d = np.diff(sig, prepend=sig[0])

    # Cross-correlation
    c = np.correlate(sig_d - np.mean(sig_d), ref_d - np.mean(ref_d), mode="full")

    lag_samples = int(np.argmax(c) - (len(ref) - 1))
    lag_ms = lag_samples * Ts * 1000.0

    return lag_samples, lag_ms


def step_rise_time(t: np.ndarray, sig: np.ndarray, cfg: CommandCompConfig, baseline: float) -> float:
    """Calculate 90% rise time for step response

    For oscillatory systems, we look for the first crossing of 90% threshold.

    Args:
        t: Time array [s]
        sig: Signal to analyze
        cfg: Configuration
        baseline: Baseline value before step

    Returns:
        Time when signal reaches 90% of step amplitude [s]
    """
    idx_step = np.searchsorted(t, cfg.step_time)

    # For 2nd order systems, look at steady-state value after transient
    # Use average of last 20% of data as final value estimate
    steady_idx = int(0.8 * len(sig))
    final_value = np.mean(sig[steady_idx:])

    # Calculate threshold based on actual final value
    threshold = baseline + 0.9 * (final_value - baseline)

    for idx in range(idx_step, len(sig)):
        if sig[idx] >= threshold:
            return t[idx]

    return float("nan")


def plot_results(
    t: np.ndarray,
    x_ideal: np.ndarray,
    x_delayed: np.ndarray,
    x_compensated: np.ndarray,
    cfg: CommandCompConfig,
) -> None:
    """Plot comparison of ideal, delayed, and compensated responses

    Args:
        t: Time array
        x_ideal: Ideal plant response (no command delay)
        x_delayed: Plant response with command delay (no compensation)
        x_compensated: Plant response with command inverse compensation
        cfg: Configuration
    """
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # Top plot: Full time range
    ax1.plot(t, x_ideal, label="Ideal (no delay)", linewidth=2, color="green")
    ax1.plot(
        t,
        x_delayed,
        label=f"Delayed (τ={cfg.tau_cmd * 1000:.0f}ms)",
        alpha=0.7,
        linewidth=2,
        color="red",
    )
    ax1.plot(
        t,
        x_compensated,
        label="With inverse compensation",
        linewidth=2,
        linestyle="--",
        color="blue",
    )
    ax1.set_xlabel("Time [s]")
    ax1.set_ylabel("Plant Output")
    ax1.set_title("Command Inverse Compensation Demo (Full Range)")
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # Bottom plot: Zoomed view around step response
    zoom_start = cfg.step_time - 0.5
    zoom_end = cfg.step_time + 2.0
    zoom_mask = (t >= zoom_start) & (t <= zoom_end)

    ax2.plot(t[zoom_mask], x_ideal[zoom_mask], label="Ideal (no delay)", linewidth=2, color="green")
    ax2.plot(
        t[zoom_mask],
        x_delayed[zoom_mask],
        label=f"Delayed (τ={cfg.tau_cmd * 1000:.0f}ms)",
        alpha=0.7,
        linewidth=2,
        color="red",
    )
    ax2.plot(
        t[zoom_mask],
        x_compensated[zoom_mask],
        label="With inverse compensation",
        linewidth=2,
        linestyle="--",
        color="blue",
    )
    ax2.axvline(cfg.step_time, color="gray", linestyle=":", alpha=0.5, label="Step command")
    ax2.set_xlabel("Time [s]")
    ax2.set_ylabel("Plant Output")
    ax2.set_title(f"Zoomed View: Step Response (t={zoom_start:.1f}s to {zoom_end:.1f}s)")
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    plt.tight_layout()

    # Save to same directory as script
    output_path = Path(__file__).resolve().parent / "command_inverse_comp_demo.png"
    plt.savefig(output_path, dpi=200)
    print(f"\nPlot saved to: {output_path}")
    plt.show()


def main() -> None:
    """Main execution function for command inverse compensation demo

    Processing flow:
    1. Generate reference command signal (from controller)
    2. Case A (No compensation): Apply delay → Send to plant → Get response
    3. Case B (With compensation): Apply inverse comp → Apply delay → Send to plant
    4. Case C (Ideal): No delay at all (reference)
    5. Compare responses and metrics

    Key insight:
    - Inverse compensation is applied BEFORE the delay
    - After delay, the command should match the original reference
    - This requires knowing the delay amount in advance
    """
    np.random.seed(42)
    cfg = CommandCompConfig()

    print("=== Command Inverse Compensation Demo ===")
    print(f"Sampling period Ts: {cfg.Ts:.3f} s")
    print(f"Command delay τ: {cfg.tau_cmd * 1000:.1f} ms ({cfg.delay_samples} samples)")
    print(f"Inverse gain a: {cfg.inverse_gain:.1f}")
    print()

    # Step 1: Generate reference command (what controller wants to send)
    t, u_ref = build_reference_signal(cfg)

    # ===== Case A: Ideal (no delay) =====
    x_ideal = propagate_second_order(u_ref, cfg)

    # ===== Case B: With delay, no compensation =====
    u_delayed = apply_command_delay(u_ref, cfg.delay_samples)
    x_delayed = propagate_second_order(u_delayed, cfg)

    # ===== Case C: With delay AND inverse compensation =====
    # Apply inverse compensation BEFORE the delay
    u_precomp = apply_command_inverse_compensation(u_ref, cfg.inverse_gain)
    # Then apply the delay
    u_comp_delayed = apply_command_delay(u_precomp, cfg.delay_samples)
    # Send through plant
    x_compensated = propagate_second_order(u_comp_delayed, cfg)

    # ===== Metrics calculation =====
    rmse_delayed = rmse(x_ideal, x_delayed)
    rmse_compensated = rmse(x_ideal, x_compensated)

    lag_delayed_samples, lag_delayed_ms = estimate_lag(x_ideal, x_delayed, cfg.Ts)
    lag_comp_samples, lag_comp_ms = estimate_lag(x_ideal, x_compensated, cfg.Ts)

    # Step response metrics
    baseline = x_ideal[np.searchsorted(t, cfg.step_time) - 1]
    rise_ideal = step_rise_time(t, x_ideal, cfg, baseline)
    rise_delayed = step_rise_time(t, x_delayed, cfg, baseline)
    rise_compensated = step_rise_time(t, x_compensated, cfg, baseline)

    # ===== Print results =====
    print("=== Tracking Performance ===")
    print(f"RMSE (delayed, no comp): {rmse_delayed:.4f}")
    print(f"RMSE (with inverse comp): {rmse_compensated:.4f}")
    print(f"Improvement: {(1 - rmse_compensated / rmse_delayed) * 100:.1f}%")
    print()

    print("=== Lag Estimation (Cross-correlation) ===")
    print(f"Lag (delayed, no comp): {lag_delayed_samples} samples (~{lag_delayed_ms:.1f} ms)")
    print(f"Lag (with inverse comp): {lag_comp_samples} samples (~{lag_comp_ms:.1f} ms)")
    print()

    print("=== Step Response (90% rise time) ===")
    print(f"Rise time (ideal):       {rise_ideal:.3f} s")
    print(f"Rise delay (no comp):    {rise_delayed - rise_ideal:.3f} s")
    print(f"Rise delay (inverse):    {rise_compensated - rise_ideal:.3f} s")
    print()

    # ===== Plot results =====
    plot_results(t, x_ideal, x_delayed, x_compensated, cfg)


if __name__ == "__main__":
    main()
